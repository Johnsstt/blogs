## 3.统计数字(9.1)
[题目链接](http://www.lintcode.com/zh-cn/problem/digit-counts/)
计算数字k在0到n中的出现的次数，k可能是0~9的一个值
### 样例
例如n=12，k=1，在 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]，我们发现1出现了5次 (1, 10, 11, 12)
### 实现
这个方法比较笨，循环每位的数，也就是循环除10的余数
```js
function addDigits(k, n) {
    let res = 0
    for (let i = 0; i <= n; i++) {
        let m = i
        if (m == 0 && k == 0) {
            res++
        } else {
            while (m>0) {
                if (m % 10 == k) {
                    res++
                }
                m = Math.floor(m / 10)
            }
        }

    }
    return res
}
console.log(addDigits(1, 12))
```
## 4.丑数 II(9.4)
[题目链接](http://www.lintcode.com/zh-cn/problem/ugly-number-ii/)
设计一个算法，找出只含素因子2，3，5 的第 n 大的数。

符合条件的数如：1, 2, 3, 4, 5, 6, 8, 9, 10, 12...
### 样例
如果n = 9， 返回 10
### 挑战
要求时间复杂度为O(nlogn)或者O(n)
### 实现
```js
function nthUglyNumber(n) {
    let count=0
    let res=[1]
    let idx=Array(3).fill(0)
    while(count<n){
        const a=2*res[idx[0]]
        const b=3*res[idx[1]]
        const c=5*res[idx[2]]

        const min=Math.min(Math.min(a,b),c)
        if(a==min){
            ++idx[0]
        }
        if(b==min){
            ++idx[1]
        }
        if(c==min){
            ++idx[2]
        }
        res.push(min)
        count++
    }
    return res[n-1]
}

console.log(nthUglyNumber(9)) // 10
```
## 5.第k大元素(9.5)
[题目链接](http://www.lintcode.com/zh-cn/problem/kth-largest-element/)
在数组中找到第k大的元素
### 样例
给出数组 [9,3,2,4,8]，第三大的元素是 4

给出数组 [1,2,3,4,5]，第一大的元素是 5，第二大的元素是 4，第三大的元素是 3，以此类推
### 实现
```js
function kthLargestElement(k,arr){
    if(!k||k<0) return false
    const beforeLen=arr.length
    arr=Array.from(new Set(arr)).sort()
    const afterLen=arr.length
    return arr[k>afterLen?beforeLen:afterLen-k]
}

console.log(kthLargestElement(2,[1,2,3,3,4,5])) //4 
```
## 15.全排列(9.8)
[题目链接](http://www.lintcode.com/zh-cn/problem/permutations/)
给定一个数字列表，返回其所有可能的排列。
### 样例
给出一个列表[1,2,3]，其全排列为：
```
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
```
### 挑战
使用递归和非递归分别解决。
### 实现
递归
```js
const origin = [1, 2, 3]
let res = []
const Len = origin.length

function permute(arr, i = 0, ele = arr[0]) {
    if (ele == origin[Len - 1] && i == Len - 1) return res
    if (i == 0) {
        ele = arr[0]
        if (ele != origin[0]) {
            i++
            return permute(arr, i, ele)
        }
        arr.shift()
    } else {
        arr.splice(i - 1, 1)
    }
    arr.splice(i, 0, ele) // insert
    res.push([].concat(arr))
    if (i < Len - 1) {
        i++
    } else {
        i = 0
    }
    return permute(arr, i, ele)
}
```
